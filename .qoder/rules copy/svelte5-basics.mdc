---
globs: *.svelte,*.js,*.ts,svelte.config.js,vite.config.js
description: Svelte 5 best practices and coding standards
---

# Svelte 5 Best Practices

## Ключевые нововведения Svelte 5

### Система рун - новый подход к реактивности

Руны - это компиляторные инструкции, которые обеспечивают явную реактивность и лучшую производительность.

#### Основные руны:

**$state** - объявление реактивного состояния:

```javascript
let count = $state(0);
let user = $state({ name: 'John', age: 30 });

// Массивы и объекты можно изменять напрямую
let items = $state([]);
items.push('new item'); // Автоматически запускает обновления
```

**$derived** - создание производных значений:

```javascript
let firstName = $state('John');
let lastName = $state('Doe');
let fullName = $derived(firstName + ' ' + lastName);

// Для сложной логики используйте $derived.by
let expensiveCalculation = $derived.by(() => {
  if (count > 10) {
    return count * 2;
  }
  return count;
});
```

**$effect** - обработка побочных эффектов:

```javascript
let count = $state(0);

$effect(() => {
  console.log(`Count changed to: ${count}`);
  // Код выполняется при изменении count
});

// Для предварительной обработки
$effect.pre(() => {
  // Выполняется перед обновлением DOM
});
```

**$props** - объявление свойств компонента:

```javascript
// MyComponent.svelte
<script>
    let { title, count = 0, onUpdate } = $props();
</script>

<h1>{title}</h1>
<p>Count: {count}</p>
<button onclick={() => onUpdate?.(count + 1)}>Increment</button>
```

## Архитектура и структура проекта

### Организация файлов и компонентов

**Рекомендуемая структура проекта:**

```
src/
├── lib/
│   ├── components/        # Переиспользуемые компоненты
│   │   ├── ui/           # UI компоненты (Button, Card, etc.)
│   │   ├── forms/        # Формы и поля
│   │   └── layout/       # Компоненты компоновки
│   ├── stores/           # Глобальные состояния
│   ├── utils/            # Утилиты и хелперы
│   └── types/            # TypeScript типы
├── routes/               # SvelteKit страницы
│   ├── api/             # API endpoints
│   └── (app)/           # Группы маршрутов
└── app.html             # HTML шаблон
```

### Создание переиспользуемых компонентов

**Базовый компонент с рунами:**

```svelte
<!-- Button.svelte -->
<script>
    let {
        variant = 'primary',
        size = 'medium',
        disabled = false,
        onclick,
        children
    } = $props();

    // Производное значение для CSS классов
    let classes = $derived(`btn btn--${variant} btn--${size}`);
</script>

<button
    class={classes}
    {disabled}
    {onclick}
    type="button"
>
    {@render children()}
</button>

<style>
    .btn {
        padding: 0.5rem 1rem;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s;
    }

    .btn--primary {
        background: #007bff;
        color: white;
    }

    .btn--secondary {
        background: #6c757d;
        color: white;
    }

    .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }
</style>
```

### Управление состоянием

**Глобальные стейты (stores):**

```javascript
// stores/user.svelte.js
let user = $state(null);
let isLoading = $state(false);

export function createUserStore() {
  return {
    get user() {
      return user;
    },
    get isLoading() {
      return isLoading;
    },

    async login(credentials) {
      isLoading = true;
      try {
        const response = await fetch('/api/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(credentials),
        });

        if (response.ok) {
          user = await response.json();
        } else {
          throw new Error('Login failed');
        }
      } finally {
        isLoading = false;
      }
    },

    logout() {
      user = null;
    },
  };
}
```

**Локальное состояние в компоненте:**

```svelte
<script>
    let items = $state([]);
    let filter = $state('');
    let isLoading = $state(false);

    // Производное значение для фильтрации
    let filteredItems = $derived(
        items.filter(item =>
            item.name.toLowerCase().includes(filter.toLowerCase())
        )
    );

    // Эффект для загрузки данных
    $effect(async () => {
        isLoading = true;
        try {
            const response = await fetch('/api/items');
            items = await response.json();
        } finally {
            isLoading = false;
        }
    });
</script>
```

## Оптимизация производительности

### Ленивая загрузка компонентов

```javascript
// Динамический импорт для больших компонентов
const LazyChart = lazy(() => import('$lib/components/Chart.svelte'));
```

```svelte
<script>
    let showChart = $state(false);
    let ChartComponent = $state(null);

    // Загружаем компонент только когда нужно
    $effect(async () => {
        if (showChart && !ChartComponent) {
            const module = await import('$lib/components/Chart.svelte');
            ChartComponent = module.default;
        }
    });
</script>

{#if showChart && ChartComponent}
    <svelte:component this={ChartComponent} />
{/if}
```

### Оптимизация реактивности

**Избегайте ненужных вычислений:**

```svelte
<script>
    let items = $state([]);
    let searchQuery = $state('');

    // ✅ Хорошо: мемоизированные вычисления
    let filteredItems = $derived(
        searchQuery ?
        items.filter(item => item.name.includes(searchQuery)) :
        items
    );

    // ❌ Плохо: вычисления в шаблоне
    // {items.filter(item => item.name.includes(searchQuery))}
</script>
```

**Используйте $derived.by для сложной логики:**

```svelte
<script>
    let data = $state([]);

    let processedData = $derived.by(() => {
        // Сложные вычисления выполняются только при изменении data
        return data
            .map(item => ({ ...item, processed: true }))
            .sort((a, b) => a.priority - b.priority)
            .slice(0, 10);
    });
</script>
```

## Обработка данных и API

### Загрузка данных в SvelteKit

**В load функциях:**

```javascript
// +page.server.js или +page.js
export async function load({ params, url, fetch }) {
  try {
    const response = await fetch(`/api/items/${params.id}`);

    if (!response.ok) {
      throw new Error(`Failed to fetch item: ${response.status}`);
    }

    const item = await response.json();

    return {
      item,
    };
  } catch (error) {
    throw error(500, 'Failed to load item');
  }
}
```

### Обработка форм

```svelte
<script>
    let formData = $state({
        name: '',
        email: '',
        message: ''
    });

    let errors = $state({});
    let isSubmitting = $state(false);

    function validateForm() {
        const newErrors = {};

        if (!formData.name.trim()) {
            newErrors.name = 'Name is required';
        }

        if (!formData.email.includes('@')) {
            newErrors.email = 'Valid email is required';
        }

        errors = newErrors;
        return Object.keys(newErrors).length === 0;
    }

    async function handleSubmit(event) {
        event.preventDefault();

        if (!validateForm()) return;

        isSubmitting = true;

        try {
            const response = await fetch('/api/contact', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(formData)
            });

            if (response.ok) {
                // Успешная отправка
                formData = { name: '', email: '', message: '' };
            } else {
                throw new Error('Submission failed');
            }
        } catch (error) {
            console.error('Form submission error:', error);
        } finally {
            isSubmitting = false;
        }
    }
</script>

<form onsubmit={handleSubmit}>
    <div>
        <label for="name">Name</label>
        <input
            id="name"
            bind:value={formData.name}
            class:error={errors.name}
        />
        {#if errors.name}
            <span class="error-text">{errors.name}</span>
        {/if}
    </div>

    <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Sending...' : 'Send'}
    </button>
</form>
```

## Тестирование

### Unit тестирование компонентов

```javascript
// Button.test.js
import { render, fireEvent } from '@testing-library/svelte';
import Button from '$lib/components/Button.svelte';

test('renders button with correct text', () => {
  const { getByRole } = render(Button, {
    props: { variant: 'primary' },
    children: () => 'Click me',
  });

  const button = getByRole('button');
  expect(button).toHaveTextContent('Click me');
  expect(button).toHaveClass('btn--primary');
});

test('calls onclick handler when clicked', async () => {
  let clicked = false;
  const handleClick = () => {
    clicked = true;
  };

  const { getByRole } = render(Button, {
    props: { onclick: handleClick },
    children: () => 'Click me',
  });

  await fireEvent.click(getByRole('button'));
  expect(clicked).toBe(true);
});
```

## Доступность (Accessibility)

### Семантическая разметка

```svelte
<script>
    let isMenuOpen = $state(false);
    let menuButton;

    function toggleMenu() {
        isMenuOpen = !isMenuOpen;
    }

    // Закрытие по Escape
    function handleKeydown(event) {
        if (event.key === 'Escape' && isMenuOpen) {
            isMenuOpen = false;
            menuButton?.focus();
        }
    }
</script>

<svelte:window onkeydown={handleKeydown} />

<nav aria-label="Main navigation">
    <button
        bind:this={menuButton}
        onclick={toggleMenu}
        aria-expanded={isMenuOpen}
        aria-controls="menu"
        aria-label="Toggle navigation menu"
    >
        Menu
    </button>

    <ul
        id="menu"
        hidden={!isMenuOpen}
        aria-hidden={!isMenuOpen}
    >
        <li><a href="/home">Home</a></li>
        <li><a href="/about">About</a></li>
        <li><a href="/contact">Contact</a></li>
    </ul>
</nav>
```

## Стилизация и темы

### CSS Custom Properties для тем

```css
/* app.css */
:root {
  /* Light theme */
  --color-bg-primary: #ffffff;
  --color-text-primary: #1a1a1a;
  --color-accent: #007bff;
  --spacing-unit: 0.25rem;
  --border-radius: 4px;
  --font-size-base: 1rem;
}

[data-theme='dark'] {
  --color-bg-primary: #1a1a1a;
  --color-text-primary: #ffffff;
  --color-accent: #4dabf7;
}
```

## Чек-листы для разработки

### Перед коммитом

- [ ] Код компилируется без ошибок (`npm run build`)
- [ ] Все тесты проходят (`npm run test`)
- [ ] Линтер не выдает ошибок (`npm run lint`)
- [ ] Код отформатирован (`npm run format`)
- [ ] Нет console.log в production коде
- [ ] Accessibility проверена (используйте axe DevTools)
- [ ] Производительность проверена в DevTools
- [ ] TypeScript типы корректны

### Code Review

- [ ] Компоненты следуют принципу единственной ответственности
- [ ] Правильное использование рун ($state, $derived, $effect)
- [ ] Нет утечек памяти в эффектах
- [ ] Обработка ошибок реализована
- [ ] Accessibility требования соблюдены
- [ ] Производительность оптимизирована
- [ ] Тесты покрывают критический функционал

## Частые ошибки новичков

### Неправильное использование рун:

```svelte
<!-- ❌ Плохо: старый синтаксис -->
<script>
    let count = 0;
    $: doubled = count * 2;
</script>

<!-- ✅ Хорошо: новый синтаксис с рунами -->
<script>
    let count = $state(0);
    let doubled = $derived(count * 2);
</script>
```

### Неправильная работа с эффектами:

```javascript
// ❌ Плохо: не очищаем интервал
$effect(() => {
  const interval = setInterval(() => {
    console.log('tick');
  }, 1000);
});

// ✅ Хорошо: очищаем ресурсы
$effect(() => {
  const interval = setInterval(() => {
    console.log('tick');
  }, 1000);

  return () => {
    clearInterval(interval);
  };
});
```

### Неправильная обработка async операций:

```svelte
<!-- ❌ Плохо: не обрабатываем ошибки -->
{#await fetch('/api/data')}
    Loading...
{:then response}
    {response.json()}
{/await}

<!-- ✅ Хорошо: полная обработка -->
{#await fetch('/api/data') then response}
    {#await response.json()}
        Processing...
    {:then data}
        <div>{data.title}</div>
    {:catch error}
        <div class="error">Failed to load data: {error.message}</div>
    {/await}
{:catch error}
    <div class="error">Network error: {error.message}</div>
{/await}
```
